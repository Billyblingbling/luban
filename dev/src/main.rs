use anyhow::{Context as _, Result};
use clap::{Parser, Subcommand};
use opendal::layers::RetryLayer;
use opendal::services::S3;
use opendal::Operator;
use serde::Deserialize;
use std::collections::HashMap;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command as ProcessCommand;
use std::process::Stdio;
use time::format_description::well_known::Rfc3339;

#[derive(Parser)]
#[command(name = "luban-dev", version, about = "Development helpers for Luban")]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Package macOS updater artifacts + a DMG installer and generate `latest.json`.
    Package {
        /// `darwin-aarch64`, `darwin-x86_64`, or `darwin-universal`.
        target: String,

        /// `release` or `debug`.
        #[arg(long, default_value = "release")]
        profile: String,

        /// Output directory for packaged artifacts.
        #[arg(long, default_value = ".context/package")]
        out_dir: PathBuf,
    },

    /// Upload packaged artifacts and the update manifest to Cloudflare R2.
    Upload {
        /// Path to the package environment file generated by `just package`.
        #[arg(long, default_value = ".context/package/package.env")]
        package_env: PathBuf,
    },
}

fn env_var(key: &str) -> Result<String> {
    std::env::var(key).with_context(|| format!("missing required env var: {key}"))
}

fn env_var_opt(key: &str) -> Option<String> {
    std::env::var(key).ok()
}

fn read_kv_file(path: &Path) -> Result<HashMap<String, String>> {
    let contents = std::fs::read_to_string(path).with_context(|| format!("read {}", path.display()))?;
    let mut out = HashMap::new();
    for (idx, line) in contents.lines().enumerate() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let (k, v) = line
            .split_once('=')
            .with_context(|| format!("invalid key=value at {}:{}", path.display(), idx + 1))?;
        let key = k.trim().to_owned();
        let value = expand_kv_value(v.trim(), &out)
            .with_context(|| format!("expand value for {key} at {}:{}", path.display(), idx + 1))?;
        out.insert(key, value);
    }
    Ok(out)
}

fn expand_kv_value(raw: &str, kv: &HashMap<String, String>) -> Result<String> {
    let mut current = raw.to_owned();
    for _ in 0..16 {
        if !current.contains("${") {
            return Ok(current);
        }
        let expanded = expand_kv_value_once(&current, kv)?;
        if expanded == current {
            break;
        }
        current = expanded;
    }
    if current.contains("${") {
        anyhow::bail!("unresolved variable reference: {current}");
    }
    Ok(current)
}

fn expand_kv_value_once(raw: &str, kv: &HashMap<String, String>) -> Result<String> {
    let mut out = String::new();
    let mut i = 0;
    while let Some(pos) = raw[i..].find("${") {
        let abs = i + pos;
        out.push_str(&raw[i..abs]);
        let var_start = abs + 2;
        let Some(end_rel) = raw[var_start..].find('}') else {
            anyhow::bail!("missing closing '}}' for variable reference");
        };
        let var_end = var_start + end_rel;
        let var = raw[var_start..var_end].trim();
        if var.is_empty() {
            anyhow::bail!("empty variable name in reference");
        }

        let replacement = kv
            .get(var)
            .cloned()
            .or_else(|| std::env::var(var).ok())
            .with_context(|| format!("unknown variable: {var}"))?;

        out.push_str(&replacement);
        i = var_end + 1;
    }
    out.push_str(&raw[i..]);
    Ok(out)
}

fn file_name(path: &Path) -> Result<String> {
    path.file_name()
        .and_then(|s| s.to_str())
        .map(|s| s.to_owned())
        .with_context(|| format!("invalid file name: {}", path.display()))
}

fn run_cmd(mut cmd: ProcessCommand, context: &str) -> Result<()> {
    let status = cmd
        .stdin(Stdio::null())
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .with_context(|| format!("spawn {context}"))?;
    if status.success() {
        return Ok(());
    }
    anyhow::bail!("{context} failed (exit {status})");
}

fn run_cmd_capture_stdout(mut cmd: ProcessCommand, context: &str) -> Result<String> {
    let output = cmd.output().with_context(|| format!("spawn {context}"))?;
    if !output.status.success() {
        anyhow::bail!(
            "{} failed (exit {}):\nstdout:\n{}\nstderr:\n{}",
            context,
            output.status,
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );
    }
    Ok(String::from_utf8_lossy(&output.stdout).trim().to_owned())
}

fn cmd_capture_stdout_if_ok(mut cmd: ProcessCommand) -> Option<String> {
    cmd.stdin(Stdio::null());
    let output = cmd.output().ok()?;
    if !output.status.success() {
        return None;
    }
    let stdout = String::from_utf8_lossy(&output.stdout).trim().to_owned();
    if stdout.is_empty() { None } else { Some(stdout) }
}

fn git_rev_parse_head() -> String {
    let mut cmd = ProcessCommand::new("git");
    cmd.args(["rev-parse", "HEAD"]);
    cmd_capture_stdout_if_ok(cmd).unwrap_or_else(|| "unknown".to_owned())
}

fn git_exact_tag() -> Option<String> {
    let mut cmd = ProcessCommand::new("git");
    cmd.args(["describe", "--tags", "--exact-match"]);
    cmd_capture_stdout_if_ok(cmd)
}

#[derive(Deserialize)]
struct CargoMetadata {
    packages: Vec<CargoPackage>,
}

#[derive(Deserialize)]
struct CargoPackage {
    name: String,
    version: String,
}

fn resolve_luban_tauri_version() -> Result<String> {
    let mut cmd = ProcessCommand::new("cargo");
    cmd.arg("metadata").arg("--no-deps").arg("--format-version").arg("1");
    let stdout = run_cmd_capture_stdout(cmd, "cargo metadata")?;
    let meta: CargoMetadata = serde_json::from_str(&stdout).context("parse cargo metadata")?;
    meta.packages
        .into_iter()
        .find(|p| p.name == "luban_tauri")
        .map(|p| p.version)
        .context("luban_tauri not found in cargo metadata")
}

fn now_rfc3339_utc() -> Result<String> {
    let ts = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .context("system clock is before unix epoch")?
        .as_secs();
    let dt = time::OffsetDateTime::from_unix_timestamp(ts as i64).context("invalid timestamp")?;
    Ok(dt.format(&Rfc3339).context("format rfc3339")?)
}

fn find_first_app_dir(bundle_macos: &Path) -> Result<Option<PathBuf>> {
    if !bundle_macos.exists() {
        return Ok(None);
    }
    for entry in std::fs::read_dir(bundle_macos).with_context(|| format!("read_dir {}", bundle_macos.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() && path.extension().and_then(|s| s.to_str()) == Some("app") {
            return Ok(Some(path));
        }
    }
    Ok(None)
}

fn find_first_file_with_extension(dir: &Path, ext: &str) -> Result<Option<PathBuf>> {
    if !dir.exists() {
        return Ok(None);
    }

    let mut matches = Vec::new();
    for entry in std::fs::read_dir(dir).with_context(|| format!("read_dir {}", dir.display()))? {
        let entry = entry?;
        let path = entry.path();
        if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some(ext) {
            matches.push(path);
        }
    }
    matches.sort_by(|a, b| a.as_os_str().cmp(b.as_os_str()));
    Ok(matches.into_iter().next())
}

fn resolve_web_version() -> Result<String> {
    let raw = std::fs::read_to_string("web/package.json").context("read web/package.json")?;
    let value: serde_json::Value = serde_json::from_str(&raw).context("parse web/package.json")?;
    value
        .get("version")
        .and_then(|v| v.as_str())
        .map(|v| v.to_owned())
        .context("missing web package.json version")
}

fn build_web(
    profile: &str,
    build_channel: &str,
    git_hash: &str,
    git_tag: &str,
    build_time: &str,
) -> Result<()> {
    if !ProcessCommand::new("pnpm").arg("--version").output().is_ok() {
        anyhow::bail!("pnpm not found; install pnpm to build the web UI");
    }

    let mut install = ProcessCommand::new("pnpm");
    install.current_dir("web").arg("install");
    run_cmd(install, "pnpm install")?;

    let web_version = resolve_web_version()?;
    let build_script = if profile == "release" { "build" } else { "build" };
    let mut build = ProcessCommand::new("pnpm");
    build
        .current_dir("web")
        .arg(build_script)
        .env("NEXT_PUBLIC_LUBAN_VERSION", web_version)
        .env("NEXT_PUBLIC_LUBAN_BUILD_CHANNEL", build_channel)
        .env("NEXT_PUBLIC_LUBAN_COMMIT", git_hash)
        .env("NEXT_PUBLIC_LUBAN_GIT_TAG", git_tag)
        .env("NEXT_PUBLIC_LUBAN_BUILD_TIME", build_time);
    run_cmd(build, "pnpm build")?;

    std::fs::create_dir_all("web/out").context("create web/out")?;
    let mut f = std::fs::File::create("web/out/.gitkeep").context("create web/out/.gitkeep")?;
    f.write_all(b"\n").context("write web/out/.gitkeep")?;

    Ok(())
}

fn sign_archive(archive_path: &Path) -> Result<String> {
    let mut help = ProcessCommand::new("cargo");
    help.arg("tauri").arg("--help");
    run_cmd(help, "cargo tauri --help")?;

    // `cargo tauri signer sign` writes a `.sig` file next to the input file.
    // Use the file as the source of truth instead of parsing stdout.
    let mut sign = ProcessCommand::new("cargo");
    sign.arg("tauri").arg("signer").arg("sign").arg(archive_path);
    run_cmd(sign, "cargo tauri signer sign")?;

    let mut extension = archive_path
        .extension()
        .context("archive has no extension")?
        .to_os_string();
    extension.push(".sig");
    let sig_path = archive_path.with_extension(extension);

    let signature = std::fs::read_to_string(&sig_path)
        .with_context(|| format!("read signature {}", sig_path.display()))?
        .trim()
        .to_owned();
    if signature.is_empty() {
        anyhow::bail!("signature file is empty: {}", sig_path.display());
    }
    Ok(signature)
}

fn package_env_required() -> Result<()> {
    let has_key = std::env::var("TAURI_PRIVATE_KEY").is_ok()
        || std::env::var("TAURI_PRIVATE_KEY_PATH").is_ok()
        || std::env::var("TAURI_SIGNING_PRIVATE_KEY").is_ok();
    if !has_key {
        anyhow::bail!(
            "missing signing key; set TAURI_PRIVATE_KEY/TAURI_PRIVATE_KEY_PATH or TAURI_SIGNING_PRIVATE_KEY"
        );
    }
    Ok(())
}

fn apply_updater_signing_env(cmd: &mut ProcessCommand) {
    if env_var_opt("TAURI_SIGNING_PRIVATE_KEY").is_none() {
        if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY", value);
        } else if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY_PATH") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY", value);
        }
    }

    if env_var_opt("TAURI_SIGNING_PRIVATE_KEY_PASSWORD").is_none() {
        if let Some(value) = env_var_opt("TAURI_PRIVATE_KEY_PASSWORD") {
            cmd.env("TAURI_SIGNING_PRIVATE_KEY_PASSWORD", value);
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct ArchiveSpec {
    program: &'static str,
    args: Vec<String>,
}

fn build_archive_spec(app_dir: &Path, archive_path: &Path, use_bsdtar: bool) -> Result<ArchiveSpec> {
    let app_parent = app_dir.parent().context("missing app parent dir")?;
    let app_name = app_dir.file_name().context("missing app dir name")?;

    if use_bsdtar {
        // The Tauri updater extracts archives via Rust's `tar` crate.
        // Some macOS metadata (xattrs/ACLs/flags) can cause extraction to fail
        // with `EPERM` on certain systems. Avoid embedding that metadata in
        // updater artifacts for better compatibility.
        let args = vec![
            "-C".to_owned(),
            app_parent.display().to_string(),
            "--no-xattrs".to_owned(),
            "--no-acls".to_owned(),
            "--no-fflags".to_owned(),
            "--no-mac-metadata".to_owned(),
            "-czf".to_owned(),
            archive_path.display().to_string(),
            app_name.to_string_lossy().to_string(),
        ];
        return Ok(ArchiveSpec { program: "bsdtar", args });
    }

    let args = vec![
        "-C".to_owned(),
        app_parent.display().to_string(),
        "-czf".to_owned(),
        archive_path.display().to_string(),
        app_name.to_string_lossy().to_string(),
    ];
    Ok(ArchiveSpec { program: "tar", args })
}

fn bsdtar_available() -> bool {
    ProcessCommand::new("bsdtar")
        .arg("--version")
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .is_ok()
}

fn build_tauri_build_command(
    target_triple: &str,
    build_flags: &[&str],
    build_channel: &str,
    git_hash: &str,
    git_tag: &str,
    build_time: &str,
) -> ProcessCommand {
    let mut cmd = ProcessCommand::new("cargo");
    cmd.current_dir("crates/luban_tauri")
        .arg("tauri")
        .arg("build")
        .arg("--ci")
        // TODO: Skip stapling until the app passes notarization.
        .arg("--skip-stapling")
        .arg("--bundles")
        .arg("app,dmg")
        .args(build_flags)
        .arg("--target")
        .arg(target_triple)
        // Always avoid Finder-driven DMG "aesthetics" because it can pop UI windows (osascript/Finder).
        // Tauri bundler enables `--skip-jenkins` when `CI=true`, which skips the AppleScript step.
        .env("CI", "true")
        .env("LUBAN_BUILD_CHANNEL", build_channel)
        .env("LUBAN_GIT_HASH", git_hash)
        .env("LUBAN_GIT_TAG", git_tag)
        .env("LUBAN_BUILD_TIME", build_time);
    cmd
}

fn run_package(target: String, profile: String, out_dir: PathBuf) -> Result<()> {
    package_env_required()?;

    let (target_triple, platform_key) = match target.as_str() {
        "darwin-aarch64" => ("aarch64-apple-darwin", "darwin-aarch64"),
        "darwin-x86_64" => ("x86_64-apple-darwin", "darwin-x86_64"),
        "darwin-universal" => ("universal-apple-darwin", "darwin-universal"),
        other => anyhow::bail!(
            "unsupported target: {}; supported targets: darwin-aarch64, darwin-x86_64, darwin-universal",
            other
        ),
    };

    let (build_dir, build_flags) = match profile.as_str() {
        "release" => ("release", Vec::<&str>::new()),
        "debug" | "dev" => ("debug", vec!["--debug"]),
        other => anyhow::bail!("unsupported profile: {}; supported: release, debug", other),
    };

    let build_channel = if profile == "release" { "release" } else { "dev" };
    let git_hash = git_rev_parse_head();
    let git_tag = if build_channel == "release" {
        git_exact_tag().unwrap_or_default()
    } else {
        String::new()
    };
    let build_time = now_rfc3339_utc()?;

    build_web(&profile, build_channel, &git_hash, &git_tag, &build_time)?;

    let mut tauri_build =
        build_tauri_build_command(target_triple, &build_flags, build_channel, &git_hash, &git_tag, &build_time);
    apply_updater_signing_env(&mut tauri_build);
    run_cmd(tauri_build, "cargo tauri build")?;

    let version = resolve_luban_tauri_version()?;
    let bundle_macos = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/macos"));
    let bundle_dmg = PathBuf::from(format!("target/{target_triple}/{build_dir}/bundle/dmg"));

    let app_dir = find_first_app_dir(&bundle_macos)?
        .with_context(|| format!("macOS bundle not found under: {}", bundle_macos.display()))?;

    std::fs::create_dir_all(&out_dir).with_context(|| format!("create {}", out_dir.display()))?;

    let dmg_path = find_first_file_with_extension(&bundle_dmg, "dmg")?
        .with_context(|| format!("DMG bundle not found under: {}", bundle_dmg.display()))?;

    let installer_name = format!("Luban_{version}_{platform_key}.dmg");
    let installer_path = out_dir.join(&installer_name);
    std::fs::copy(&dmg_path, &installer_path)
        .with_context(|| format!("copy {} to {}", dmg_path.display(), installer_path.display()))?;

    let archive_name = format!("Luban_{version}_{platform_key}.app.tar.gz");
    let archive_path = out_dir.join(&archive_name);

    let spec = build_archive_spec(&app_dir, &archive_path, bsdtar_available())?;
    let mut archive = ProcessCommand::new(spec.program);
    archive.args(spec.args);
    run_cmd(archive, "archive app")?;

    let signature = sign_archive(&archive_path)?;

    let mut sig_ext = archive_path
        .extension()
        .context("archive has no extension")?
        .to_os_string();
    sig_ext.push(".sig");
    let sig_path = archive_path.with_extension(sig_ext);

    let base_url = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    let url = format!("{}/{}/{}", base_url.trim_end_matches('/'), version, archive_name);
    let pub_date = now_rfc3339_utc()?;

    let platforms = if platform_key == "darwin-universal" {
        HashMap::from([
            ("darwin-aarch64".to_owned(), ManifestPlatform { url: url.clone(), signature: signature.clone() }),
            ("darwin-x86_64".to_owned(), ManifestPlatform { url, signature }),
        ])
    } else {
        HashMap::from([(platform_key.to_owned(), ManifestPlatform { url, signature })])
    };

    let manifest = Manifest {
        version: version.clone(),
        notes: "".to_owned(),
        pub_date,
        platforms,
    };

    let manifest_path = out_dir.join("latest.json");
    std::fs::write(&manifest_path, serde_json::to_string_pretty(&manifest)?.to_owned() + "\n")
        .with_context(|| format!("write {}", manifest_path.display()))?;

    let env_path = out_dir.join("package.env");
    let env_contents = format!(
        "LUBAN_PACKAGE_VERSION={}\nLUBAN_PACKAGE_PLATFORM_KEY={}\nLUBAN_PACKAGE_ARCHIVE={}\nLUBAN_PACKAGE_SIGNATURE={}\nLUBAN_PACKAGE_MANIFEST={}\nLUBAN_PACKAGE_INSTALLER={}\n",
        version,
        platform_key,
        archive_path.display(),
        sig_path.display(),
        manifest_path.display(),
        installer_path.display(),
    );
    std::fs::write(&env_path, env_contents).with_context(|| format!("write {}", env_path.display()))?;

    println!("installer: {}", installer_path.display());
    println!("packaged: {}", archive_path.display());
    println!("manifest: {}", manifest_path.display());
    println!("next: just upload");

    Ok(())
}

#[derive(serde::Serialize)]
struct Manifest {
    version: String,
    notes: String,
    pub_date: String,
    platforms: HashMap<String, ManifestPlatform>,
}

#[derive(serde::Serialize)]
struct ManifestPlatform {
    url: String,
    signature: String,
}

fn build_r2_operator(
    endpoint_url: &str,
    bucket: &str,
    region: &str,
    access_key_id: &str,
    secret_access_key: &str,
    session_token: Option<&str>,
) -> Result<Operator> {
    let mut builder = S3::default()
        .endpoint(endpoint_url)
        .bucket(bucket)
        .region(region)
        .access_key_id(access_key_id)
        .secret_access_key(secret_access_key);

    if let Some(token) = session_token {
        if !token.trim().is_empty() {
            builder = builder.session_token(token);
        }
    }

    // Avoid metadata calls that don't apply to local packaging workflows.
    let builder = builder.disable_ec2_metadata().disable_stat_with_override();

    Ok(Operator::new(builder)
        .context("build opendal S3 operator")?
        .layer(RetryLayer::new())
        .finish())
}

async fn upload_file(
    op: &Operator,
    bucket: &str,
    key: &str,
    path: &Path,
    content_type: &str,
    cache_control: &str,
) -> Result<()> {
    let body = tokio::fs::read(path)
        .await
        .with_context(|| format!("read upload body {}", path.display()))?;
    op.write_with(key, body)
        .content_type(content_type)
        .cache_control(cache_control)
        .await
        .with_context(|| format!("upload s3://{bucket}/{key}"))?;
    Ok(())
}

async fn run_upload(package_env: PathBuf) -> Result<()> {
    let r2_endpoint_url = env_var("R2_ENDPOINT_URL")?;
    let r2_bucket = env_var("R2_BUCKET")?;
    let access_key = env_var("AWS_ACCESS_KEY_ID")?;
    let secret_key = env_var("AWS_SECRET_ACCESS_KEY")?;
    let session_token = env_var_opt("AWS_SESSION_TOKEN");
    let region = env_var_opt("AWS_DEFAULT_REGION").unwrap_or_else(|| "auto".to_owned());

    let kv = read_kv_file(&package_env)?;
    let version = kv
        .get("LUBAN_PACKAGE_VERSION")
        .context("LUBAN_PACKAGE_VERSION missing from package.env")?
        .trim()
        .to_owned();
    let platform_key = kv
        .get("LUBAN_PACKAGE_PLATFORM_KEY")
        .context("LUBAN_PACKAGE_PLATFORM_KEY missing from package.env")?
        .trim()
        .to_owned();
    let archive_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_ARCHIVE")
            .context("LUBAN_PACKAGE_ARCHIVE missing from package.env")?,
    );
    let signature_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_SIGNATURE")
            .context("LUBAN_PACKAGE_SIGNATURE missing from package.env")?,
    );
    let manifest_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_MANIFEST")
            .context("LUBAN_PACKAGE_MANIFEST missing from package.env")?,
    );
    let installer_path = kv
        .get("LUBAN_PACKAGE_INSTALLER")
        .map(|p| p.trim())
        .filter(|p| !p.is_empty())
        .map(PathBuf::from);

    let archive_name = file_name(&archive_path)?;
    let archive_key = format!("{version}/{archive_name}");
    let signature_key = format!("{archive_key}.sig");

    let op = build_r2_operator(
        &r2_endpoint_url,
        &r2_bucket,
        &region,
        &access_key,
        &secret_key,
        session_token.as_deref(),
    )?;

    upload_file(
        &op,
        &r2_bucket,
        &archive_key,
        &archive_path,
        "application/gzip",
        "public, max-age=31536000, immutable",
    )
    .await?;

    upload_file(
        &op,
        &r2_bucket,
        &signature_key,
        &signature_path,
        "text/plain; charset=utf-8",
        "public, max-age=31536000, immutable",
    )
    .await?;

    upload_file(
        &op,
        &r2_bucket,
        "latest.json",
        &manifest_path,
        "application/json; charset=utf-8",
        "no-cache",
    )
    .await?;

    if let Some(installer_path) = installer_path {
        let installer_name = file_name(&installer_path)?;
        let installer_key = format!("{version}/{installer_name}");
        upload_file(
            &op,
            &r2_bucket,
            &installer_key,
            &installer_path,
            "application/x-apple-diskimage",
            "public, max-age=31536000, immutable",
        )
        .await?;

        let installer_latest_key = format!("Luban_latest_{platform_key}.dmg");
        upload_file(
            &op,
            &r2_bucket,
            &installer_latest_key,
            &installer_path,
            "application/x-apple-diskimage",
            "no-cache",
        )
        .await?;
    }

    let base = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    println!("uploaded: {}/latest.json", base.trim_end_matches('/'));

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Package { target, profile, out_dir } => run_package(target, profile, out_dir),
        Command::Upload { package_env } => run_upload(package_env).await,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::OsStr;

    #[test]
    fn expand_kv_value_uses_prior_kv_entries() {
        let kv = HashMap::from([("FOO".to_owned(), "bar".to_owned())]);
        let expanded = expand_kv_value("prefix-${FOO}-suffix", &kv).expect("must expand");
        assert_eq!(expanded, "prefix-bar-suffix");
    }

    #[test]
    fn expand_kv_value_uses_process_env() {
        let kv = HashMap::new();
        let prev = std::env::var_os("LUBAN_TEST_ENV");
        unsafe {
            std::env::set_var("LUBAN_TEST_ENV", "value");
        }
        let expanded = expand_kv_value("${LUBAN_TEST_ENV}", &kv).expect("must expand");
        assert_eq!(expanded, "value");
        if let Some(v) = prev {
            unsafe {
                std::env::set_var("LUBAN_TEST_ENV", v);
            }
        } else {
            unsafe {
                std::env::remove_var("LUBAN_TEST_ENV");
            }
        }
    }

    #[test]
    fn expand_kv_value_errors_on_unknown_variable() {
        let kv = HashMap::new();
        let err = expand_kv_value("${LUBAN_TEST_ENV_MISSING}", &kv)
            .expect_err("must error on missing variable");
        assert!(format!("{err:#}").contains("unknown variable"));
    }

    #[test]
    fn build_archive_spec_uses_bsdtar_flags() {
        let app_dir = Path::new("/tmp/Luban.app");
        let archive_path = Path::new("/tmp/Luban_0.1.5_darwin-aarch64.app.tar.gz");
        let spec = build_archive_spec(app_dir, archive_path, true).expect("must build spec");
        assert_eq!(spec.program, "bsdtar");
        assert!(spec.args.iter().any(|arg| arg == "--no-xattrs"));
        assert!(spec.args.iter().any(|arg| arg == "--no-acls"));
        assert!(spec.args.iter().any(|arg| arg == "--no-fflags"));
        assert!(spec.args.iter().any(|arg| arg == "--no-mac-metadata"));
    }

    #[test]
    fn find_first_file_with_extension_returns_sorted_match() {
        let unique = format!(
            "luban-dev-test-{}-{}",
            std::process::id(),
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .expect("must get time")
                .as_nanos()
        );
        let root = std::env::temp_dir().join(unique);
        std::fs::create_dir_all(&root).expect("must create root dir");

        let a = root.join("a.dmg");
        let b = root.join("b.dmg");
        std::fs::write(&b, b"b").expect("must write b");
        std::fs::write(&a, b"a").expect("must write a");
        std::fs::write(root.join("c.txt"), b"c").expect("must write c");

        let found = find_first_file_with_extension(&root, "dmg")
            .expect("must scan")
            .expect("must find dmg");
        assert_eq!(found, a);

        std::fs::remove_dir_all(&root).expect("must cleanup");
    }

    #[test]
    fn tauri_build_always_sets_ci_true() {
        let cmd = build_tauri_build_command(
            "aarch64-apple-darwin",
            &[],
            "release",
            "deadbeef",
            "v0.0.0",
            "2026-01-23T00:00:00Z",
        );
        let ci = cmd
            .get_envs()
            .find_map(|(key, value)| if key == OsStr::new("CI") { value } else { None });
        assert_eq!(ci, Some(OsStr::new("true")));
    }
}
