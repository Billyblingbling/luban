use anyhow::{Context as _, Result};
use aws_config::BehaviorVersion;
use aws_credential_types::Credentials;
use aws_sdk_s3::config::Region;
use aws_sdk_s3::primitives::ByteStream;
use clap::{Parser, Subcommand};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[command(name = "luban-dev", version, about = "Development helpers for Luban")]
struct Cli {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Upload packaged artifacts and the update manifest to Cloudflare R2.
    Upload {
        /// Path to the package environment file generated by `just package`.
        #[arg(long, default_value = ".context/package/package.env")]
        package_env: PathBuf,
    },
}

fn env_var(key: &str) -> Result<String> {
    std::env::var(key).with_context(|| format!("missing required env var: {key}"))
}

fn env_var_opt(key: &str) -> Option<String> {
    std::env::var(key).ok()
}

fn read_kv_file(path: &Path) -> Result<HashMap<String, String>> {
    let contents = std::fs::read_to_string(path).with_context(|| format!("read {}", path.display()))?;
    let mut out = HashMap::new();
    for (idx, line) in contents.lines().enumerate() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }
        let (k, v) = line
            .split_once('=')
            .with_context(|| format!("invalid key=value at {}:{}", path.display(), idx + 1))?;
        out.insert(k.trim().to_owned(), v.trim().to_owned());
    }
    Ok(out)
}

async fn put_object(
    client: &aws_sdk_s3::Client,
    bucket: &str,
    key: &str,
    path: &Path,
    content_type: &str,
    cache_control: &str,
) -> Result<()> {
    let body = ByteStream::from_path(path.to_path_buf())
        .await
        .with_context(|| format!("read upload body {}", path.display()))?;
    client
        .put_object()
        .bucket(bucket)
        .key(key)
        .cache_control(cache_control)
        .content_type(content_type)
        .body(body)
        .send()
        .await
        .with_context(|| format!("upload s3://{bucket}/{key}"))?;
    Ok(())
}

fn file_name(path: &Path) -> Result<String> {
    path.file_name()
        .and_then(|s| s.to_str())
        .map(|s| s.to_owned())
        .with_context(|| format!("invalid file name: {}", path.display()))
}

async fn run_upload(package_env: PathBuf) -> Result<()> {
    let r2_endpoint_url = env_var("R2_ENDPOINT_URL")?;
    let r2_bucket = env_var("R2_BUCKET")?;
    let access_key = env_var("AWS_ACCESS_KEY_ID")?;
    let secret_key = env_var("AWS_SECRET_ACCESS_KEY")?;
    let session_token = env_var_opt("AWS_SESSION_TOKEN");
    let region = env_var_opt("AWS_DEFAULT_REGION").unwrap_or_else(|| "auto".to_owned());

    let kv = read_kv_file(&package_env)?;
    let archive_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_ARCHIVE")
            .context("LUBAN_PACKAGE_ARCHIVE missing from package.env")?,
    );
    let signature_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_SIGNATURE")
            .context("LUBAN_PACKAGE_SIGNATURE missing from package.env")?,
    );
    let manifest_path = PathBuf::from(
        kv.get("LUBAN_PACKAGE_MANIFEST")
            .context("LUBAN_PACKAGE_MANIFEST missing from package.env")?,
    );

    let archive_key = file_name(&archive_path)?;
    let signature_key = format!("{archive_key}.sig");

    let credentials = Credentials::new(access_key, secret_key, session_token, None, "env");

    let shared_config = aws_config::defaults(BehaviorVersion::latest())
        .region(Region::new(region))
        .credentials_provider(credentials)
        .load()
        .await;

    let s3_config = aws_sdk_s3::config::Builder::from(&shared_config)
        .endpoint_url(r2_endpoint_url)
        // Cloudflare R2 endpoints are typically not wildcard-cert'ed for virtual host style.
        // Force path-style addressing to avoid TLS hostname mismatch.
        .force_path_style(true)
        .build();

    let client = aws_sdk_s3::Client::from_conf(s3_config);

    put_object(
        &client,
        &r2_bucket,
        &archive_key,
        &archive_path,
        "application/gzip",
        "public, max-age=31536000, immutable",
    )
    .await?;

    put_object(
        &client,
        &r2_bucket,
        &signature_key,
        &signature_path,
        "text/plain; charset=utf-8",
        "public, max-age=31536000, immutable",
    )
    .await?;

    put_object(
        &client,
        &r2_bucket,
        "latest.json",
        &manifest_path,
        "application/json; charset=utf-8",
        "no-cache",
    )
    .await?;

    let base = env_var_opt("LUBAN_RELEASE_BASE_URL").unwrap_or_else(|| "https://releases.luban.dev".to_owned());
    println!("uploaded: {}/latest.json", base.trim_end_matches('/'));

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.cmd {
        Command::Upload { package_env } => run_upload(package_env).await,
    }
}

